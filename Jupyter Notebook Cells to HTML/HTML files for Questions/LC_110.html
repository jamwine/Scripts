<h2>110. Balanced Binary Tree</h2>

<pre><code>Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

Example 1:

Given the following tree [3,9,20,null,null,15,7]:

    3
   / \
  9  20
    /  \
   15   7
Return true.

Example 2:

Given the following tree [1,2,2,3,3,null,null,4,4]:

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4

Return false.
</code></pre>

<h3>Solution</h3>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">depthAndBalan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span>
        <span class="n">hL</span><span class="p">,</span> <span class="n">leftBal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depthAndBalan</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">hR</span><span class="p">,</span> <span class="n">rightBal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depthAndBalan</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">hL</span> <span class="o">-</span> <span class="n">hR</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">hL</span><span class="p">,</span> <span class="n">hR</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">leftBal</span> <span class="ow">and</span> <span class="n">rightBal</span> <span class="ow">and</span> <span class="n">balance</span>

    <span class="k">def</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">depthAndBalan</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</code></pre>
</div>

<p><strong>Time complexity</strong> : O(N), where N is a number of nodes, since we visit each node</p>

<p><strong>Space complexity</strong> : O(H), H is the tree height to keep the recursion stack, in worst case when the tree is skewed, O(N)</p>
