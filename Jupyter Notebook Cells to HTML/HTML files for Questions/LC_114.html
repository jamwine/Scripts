<h2>114. Flatten Binary Tree to Linked List</h2>

<pre><code>Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre>

<h3>Solution</h3>

<div class="codehilite">
<pre><span></span><code><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify root in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Using Morris Traversal, O(1) space and O(N) complexity</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>

            <span class="c1"># If the node has a left child</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>

                <span class="c1"># Find the rightmost node</span>
                <span class="n">rightmost</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
                <span class="k">while</span> <span class="n">rightmost</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">rightmost</span> <span class="o">=</span> <span class="n">rightmost</span><span class="o">.</span><span class="n">right</span>

                <span class="c1"># rewire the connections</span>
                <span class="n">rightmost</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
                <span class="n">current</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
                <span class="n">current</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># move on to the right side of the tree</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
</code></pre>
</div>

<p><strong>Time complexity</strong> : O(N), where N is a number of nodes, since we visit each node</p>

<p><strong>Space complexity</strong> : O(1), no extra space required while rewiring the connections</p>
